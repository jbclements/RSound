#lang racket/base

(require (for-syntax racket/base syntax/parse)
         racket/contract
         racket/stxparam
         (only-in lang/private/teachprims beginner-<=))


(provide network
         prev
         signal?
         filter?
         signal-*s
         signal-+s
         (struct-out network/s)
         (contract-out [network-init (-> network/c procedure?)])
         const-network
         loop-ctr
         loop-ctr/variable
         simple-ctr
         frame-ctr
         signal-samples
         signal-nth
         tap
         choose-net)

;; a network is either a function or (make-network ins outs producer-maker)
;; where ins is a natural number representing the number of inputs, 
;; outs is a natural number representing the number of outputs, and
;; producer-maker is a procedure of no arguments that returns a procedure
;; (possibly taking arguments) that returns signal values.

;; ins and outs not currently used, could be used for static checking...
;; or for better error messages, at any rate.

(struct network/s (ins outs maker))



(define network/c (or/c network/s? procedure?))

;; given a network/c, initialize it and return a thunk that 
;; produces samples
(define (network-init net)
  (cond [(network/s? net) ((network/s-maker net))]
        [(procedure? net) net]
        [else (raise-argument-error
               'signal-init
               "network or procedure" net)]))

;; for uses of <=, we must initialize the network
(define-syntax (maybe-init stx)
  (syntax-parse stx
    #:datum-literals (<= =)
    [(_ (<= network:expr other:expr ...)) 
     #`(network-init network)]
    [(_ (= rhs:expr)) #'#f]))

;; take a step in the signal. This may involve
;; simply evaluating an expression, or calling 
;; a network's signal function
(define-syntax (generate stx)
  (syntax-parse stx
    #:datum-literals (<= =)
    ;; call the signal fun generated by the init, ignore
    ;; the network expression:
    [(_ signal-fun (<= network:expr other:expr ...))
     #'(signal-fun other ...)]
    ;; just evaluate the rhs expr:
    [(_ signal-fun (= rhs:expr))
     #'rhs]))

;; maker: (-> (arg ... -> result ...))

(define-syntax-parameter prev (lambda (stx)
                                #'(error "can't use prev outside of a network definition")))

;; a network consists of a list of inputs, and a collection of clauses.
;; each clause represents a node in a dataflow-like network. Cycles
;; may be modeled by using the 'prev' form which allows references
;; to prior node values.
;;
;; The expansion uses mutable variables to store values associated with
;; nodes. Currently, it stores values for all nodes, though this is 
;; required only for nodes that are referred to using 'prev' clauses.
;; 
(define-syntax (network/inr stx)
  (define-syntax-class network-clause
    #:description "network/inr clause"
    (pattern ((out:id ...) rhs:expr)))
  (syntax-parse stx
    [(_ (in:id ...)
        clause:network-clause ...+)
     (define num-ins (length (syntax->list #'(in ...))))
     (define lhses (syntax->list #'((clause.out ...) ...)))
     (define num-outs (length (syntax->list (car (reverse lhses)))))
     (define lhses/flattened (syntax->list #'(clause.out ... ...)))
     (with-syntax
         ([(saved-val ...) (generate-temporaries lhses/flattened)]
          [(signal-proc ...) (generate-temporaries #'(clause ...))]
          [(lhs ...) lhses/flattened]
          [last-out
           (syntax-parse (car (reverse lhses))
             [(out:id) #'out]
             [(out:id out2:id ...+) #'(values out out2 ...)])])
       (with-syntax
           ;; the first and subsequent uses of the network will
           ;; get different meanings of the 'prev' macro. In the 
           ;; first case, the 'prev' macro reduces to the init
           ;; value. In later uses, it reduces to a reference to
           ;; the prior value.
           (;; this one just reduces to the init:
            [init-prev
             #`(lambda (stx)
                 (syntax-parse stx
                   #:literals (prev)
                   [(_ id init) #'init]))]
            ;; this one does a lookup:
            ;; NB: TOTALLY SCARY MACRO STUFF HERE: this is 
            ;; expanding into a macro definition. The macro
            ;; definition that goes into the code doesn't
            ;; have any dots in it.
            [lookup-prev
             #'(lambda (stx)
                 (syntax-case stx (lhs ...)
                   [(_ lhs init) #'saved-val] 
                   ...))]
            ;; the body of the function is the same for each one,
            ;; just nested inside a different syntax-parameterize
            [fun-body
             #`(let*-values ([(clause.out ...) (generate signal-proc 
                                                         clause.rhs)]
                             ...)
                 (begin
                   (set! saved-val lhs)
                   ...)
                 last-out)])
         (with-syntax
             ([maker
               #`(lambda ()
                   (define saved-val #f)
                   ...
                   ;; for the = exprs, these signal-procs will just be #f:
                   (define signal-proc (maybe-init clause.rhs))
                   ...
                   ;; this one should be used only after the saved-vals
                   ;; are initialized
                   (define (later-times-fun in ...)
                     ;; in this one, "prev" should do a lookup
                     (syntax-parameterize
                      ([prev lookup-prev])
                      fun-body))
                   (define (first-time-fun in ...)
                     ;; mutate myself into the later-times-fun...
                     (set! first-time-fun later-times-fun)
                     ;; in this one, "prev" should just insert the init vals
                     (syntax-parameterize
                      ([prev init-prev])
                      fun-body))
                   (lambda (in ...)
                     (first-time-fun in ...)))])
           #`(network/s (quote #,num-ins) 
                        (quote #,num-outs)
                        maker))))]))

;; the syntactic form that is exported. It tries to 
;; give reasonable error messages (using syntax-parse),
;; wraps lonely lhs ids in parens, and rewrites into
;; network/inr
(define-syntax (network stx)
  ;; id or (id ...)
  (define-syntax-class oneormoreids
    #:description "id or (id ...)"
    (pattern out:id)
    (pattern (outs:id ...)))
  ;; the rhs of a network clause
  (define-syntax-class network-clause-rhs
    #:description "network clause rhs"
    #:literals (prev)
    #:datum-literals (<= =)
    (pattern (= konst:expr))
    (pattern (<= node:expr input:expr ...)))
  ;; a network clause
  (define-syntax-class network-clause
    #:description "network clause"
    #:literals (prev)
    #:datum-literals (<= =)
    (pattern (outs:oneormoreids . rhs:network-clause-rhs)))
  ;; map id to (id), leave (id ...) alone
  (define (ensure-parens ids)
    (syntax-parse ids
      [out:id #'(out)]
      [(outs:id ...) #'(outs ...)]))
  ;; rewrite into network/inr
  (syntax-parse stx
    [(_ (in:id ...)
        clause:network-clause ...+)
     (with-syntax ([((outs ...) ...)
                    (map ensure-parens (syntax->list #'(clause.outs ...)))])
       #'(network/inr (in ...)
                      [(outs ...) clause.rhs] ...))])
  )


;; a signal is a network with no inputs.
(define (signal? f)
  (or (and (network/s? f) (= (network/s-ins f) 0))
      (and (procedure? f) (procedure-arity-includes? f 0))))

;; a filter is a network with 1 inputs.
(define (filter? f)
  (or (and (network/s? f) (= (network/s-ins f) 1))
      (and (procedure? f) (procedure-arity-includes? f 1))))

;; take a network with inputs and a set of fixed 
;; inputs and return a new signal closed over those inputs
(define-syntax (const-network stx)
  (syntax-parse stx
    [(_ net arg ...)
     #'(network () [out <= net arg ...])]))

;; multiply the signals together:
(define (signal-*s los)
  (unless (andmap signal? los)
    (raise-argument-error 'signal-*s "list of signals" 0 los))
  (network/s 0 1 (lambda ()
                   (define sigfuns (map network-init los))
                   (lambda ()
                     (for/product ([fun sigfuns]) (fun))))))

;; add the signals together:
(define (signal-+s los)
  (unless (andmap signal? los)
    (raise-argument-error 'signal-*s "list of signals" 0 los))
  (network/s 0 1 (lambda ()
                   (define sigfuns (map network-init los))
                   (lambda ()
                     (for/sum ([fun sigfuns]) (fun))))))

;; a simple signal that starts at 0 and increments by "skip"
;; until it passes "len", then jumps back by "len"
(define (loop-ctr len skip)
  (define (increment p)
    (define next-p (+ p skip))
    (cond [(< next-p len) next-p]
          [else (- next-p len)]))
  (network ()
           [a = (prev b 0)]
           [b = (increment a)]
           [out = a]))

;; a simple signal that starts at 0 and increments by "skip"
;; until it passes "len", then jumps back by "len", but "skip"
;; can be dynamically adjusted
(define (loop-ctr/variable len)
  (define (increment p skip)
    (define next-p (+ p skip))
    (cond [(< next-p len) next-p]
          [else (- next-p len)]))
  (network (skip)
           [a = (prev b 0)]
           [b = (increment a skip)]
           [out = a]))

;; a signal that simply starts at "init"  and adds "skip"
;; each time
(define (simple-ctr init skip)
  (network ()
           [a = (prev b init)]
           [b = (+ skip a)]
           [out = a]))

;; a signal that counts up from zero
(define frame-ctr (simple-ctr 0 1))

;; a vector containing the first 'n' samples of a signal
(define (signal-samples signal n)
  (define sigfun (network-init signal))
  (for/vector ([i n]) (sigfun)))

;; determine the nth sample, by discarding the first n-1:
(define (signal-nth signal n)
  (unless (exact-nonnegative-integer? n)
    (raise-argument-error 'signal-nth
                          "natural number"
                          1 signal n))
  (define sigfun (network-init signal))
  (for ([i n]) (sigfun))
  (sigfun))

;; create a tap of the given length (we could generalize
;; this to allow multiple tap lengths from one vector.)
;; for now, it assumes real-valued inputs, and pre-fills
;; the vector with the init-val.
;; nat -> network
(define (tap len init-val)
  (define the-proc
    (lambda ()
      (define tap-vec (make-vector len init-val))
      (define idx 0)
      (lambda (new-val)
        (begin0 (vector-ref tap-vec idx)
                (vector-set! tap-vec idx new-val)
                (let ()
                  (define next-idx (add1 idx))
                  (set! idx (cond [(< next-idx len) next-idx]
                                  [else 0])))))))
  (network/s 1 1 the-proc))



;; choose between one of two signals. If the first signal is #t, call
;; the first signal with the remainder of the arguments. If not, call
;; the second signal with the remainder of the arguments.
;; network network -> network
(define (choose-net network1 network2)
  (unless (network/s? network1)
    (raise-argument-error 'choose "network" 0 network1 network2))
  (unless (network/s? network2)
    (raise-argument-error 'choose "network" 1 network1 network2))
  (unless (= (network/s-ins network1) (network/s-ins network2))
    (raise-argument-error 'choose "networks with same number of inputs"
                          1 network1 network2))
  (unless (= (network/s-outs network1) (network/s-outs network2))
    (raise-argument-error 'choose "networks with same number of outputs"
                          1 network1 network2))
  (network/s (network/s-ins network1)
             (network/s-outs network1)
             (lambda ()
               (define net1proc (network-init network1))
               (define net2proc (network-init network2))
               (lambda (use-first? . args)
                 (if use-first?
                     (apply net1proc args)
                     (apply net2proc args))))))